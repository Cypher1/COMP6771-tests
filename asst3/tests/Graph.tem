template <typename N, typename E>
class Graph {
    private:
        class Node {
            private:
                class Edge {
                    private:
                        std::weak_ptr<Node> dst;
                        E weight;

                    public:
                        Edge(const std::weak_ptr<Node>& dst, const E& weight): dst{dst}, weight{weight} {}

                        ~Edge() {
                            //std::cout << "REMOVE EDGE" << std::endl;
                        } // dst and weight are automatically deleted

                        bool exists() const {
                            return !dst.expired();
                        }

                        const std::shared_ptr<Node> getDst() const {
                            return dst.lock();
                        }

                        const E getWeight() const {
                            return weight;
                        }

                        void setDst(std::shared_ptr<Node> ndst) {
                            dst = ndst;
                        }

                        bool operator == (const Edge& other) const {
                            if(weight != other.weight) return false;
                            if(*(dst.lock()) != *(other.dst.lock())) return false;
                            return true;
                        }

                        bool operator != (const Edge& other) const {
                            return !(*this == other);
                        }

                        void printEdge() const noexcept{
                            if(exists()) {
                                std::cout << getDst()->getLabel() << " " << weight;
                            }
                        }
                };

                std::shared_ptr<N> label;
                std::vector<std::shared_ptr<Edge>> edges;
                std::vector<std::weak_ptr<Edge>> back_edges;

            public:
                Node(const std::shared_ptr<N> label): label{label} {}

                ~Node() {
                    //std::cout << "REMOVE NODE " << *label << "\n";
                }
                /*
                Node(const Node& onode) { // copy constructor
                    label = std::make_shared<N>(onode.getLabel());
                    //TODO DEEP COPY EDGES
                }

                Node& operator = (const Node& onode) { // copy assignment
                    if(this != &onode) {
                        label = std::make_shared<N>(onode.getLabel());
                        //TODO DEEP COPY EDGES
                    }
                    return *this;
                }

                Node(Node&& onode) { // move constructor
                    if(this != &onode) {
                        // TODO
                    }
                }

                Node& operator = (Node&& onode) { // move assignment
                    if(this != &onode) {
                        // TODO
                    }
                    return *this;
                }
                */
                N getLabel() const {
                    return *label;
                }

                int getOutDegree() const {
                    unsigned int n_edges = 0;
                    for(auto edge : edges) {
                        if(edge->exists()) {
                            n_edges++;
                        } else {
                            //TODO delete
                        }
                    }
                    return n_edges;
                }

                void setLabel(const std::shared_ptr<N>& repl) {
                    label = repl;
                }

                bool addEdge(const std::shared_ptr<Node>& shared, const std::shared_ptr<Node>& node, const E& weight) {
                    std::shared_ptr<Edge> edge_ptr{new Edge(node, weight)};
                    for(auto edge : edges) {
                        if(edge->exists()) { // this edge still exists
                            if(*edge == *edge_ptr) { // and they are the same
                                return false;
                            }
                        }
                    }
                    edges.push_back(edge_ptr);
                    node->addBackEdge(node, edge_ptr);
                    return true;
                }

                void addBackEdge(const std::shared_ptr<Node>& shared, const std::weak_ptr<Edge>& edge) {
                    if(!edge.expired()) {
                        back_edges.push_back(edge);
                        edge.lock()->setDst(shared);
                    }
                }

                void mergeEdges(const std::shared_ptr<Node>& shared, const std::shared_ptr<Node>& other) {
                    for(auto edge_it : other->edges) {
                        addEdge(shared, edge_it->getDst(), edge_it->getWeight());
                    }
                    for(auto edge_it : other->back_edges) {
                        std::shared_ptr<Edge> edge_ptr = edge_it.lock();
                        addBackEdge(shared, edge_ptr);
                    }
                }

                auto findEdge(const N& dst) const {
                    for(auto it = edges.begin(); it != edges.end(); ++it) {
                        if((*it)->exists()) { // this edge still exists
                            std::shared_ptr<Node> edge_dst = (*it)->getDst();
                            if(edge_dst->getLabel() == dst) {
                                return it;
                            }
                        } else {
                            //auto del_it = it;
                            //it--; //go back one
                            //TODO edges.erase(del_it);
                        }
                    }
                    return edges.end();
                }

                const std::vector<std::shared_ptr<Edge>> getEdges() const {
                    return edges;
                }

                bool hasEdge(const N& dst) const {
                    //printNode();
                    return findEdge(dst) != edges.end();
                }

                void deleteEdge(const N& dst, const E& w) noexcept { // Remove an Edge
                    auto edge_it = findEdge(dst);
                    if(edge_it != edges.end()) {
                        edges.erase(edge_it); // remove the edge
                    }
                }

                void printNode() {
                    std::cout << "Edges attached to Node " << *label << "\n";
                    struct edge_compare {
                        bool operator() (const std::shared_ptr<Edge>& e1, const std::shared_ptr<Edge>& e2) const {
                            if(e1->getWeight() == e2->getWeight()) {
                                return e1->getDst()->getLabel() < e2->getDst()->getLabel();
                            }
                            return e1->getWeight() < e2->getWeight();
                        }
                    };
                    std::sort(edges.begin(), edges.end(), edge_compare());

                    unsigned int num_edges = 0;
                    for(auto edge : edges) {
                        if(edge->exists()) {
                            edge->printEdge();
                            std::cout << "\n";
                            num_edges++;
                        }
                    }
                    if(num_edges == 0) {
                        std::cout << "(null)\n";
                    }
                }

                bool operator == (const Node& other) const {
                    return getLabel() == other.getLabel();
                }
                bool operator != (const Node& other) const {
                    return !(*this == other);
                }

        };

        std::map<N, std::shared_ptr<Node>> nodes;
        mutable int iter;

    public:
        Graph() {
            begin(); // setup the iterator
        } // constructor

        ~Graph() { // destructor
        }

        Graph(const Graph& ograph) { // copy constructor
            copyGraph(ograph);
        }

        Graph& operator = (const Graph& ograph) { // copy assignment
            if(this != &ograph) {
                clear();
                copyGraph(ograph);
            }
            return *this;
        }

        void copyGraph(const Graph& ograph) {
            if(this != &ograph) {
                iter = ograph.iter; // Copy the iterator
                for(auto node : ograph.nodes) {
                    addNode(node.first);
                }
                for(auto node : ograph.nodes) {
                    for(auto edge : node.second->getEdges()) {
                        if(edge->exists()) {
                            addEdge(node.first, edge->getDst()->getLabel(), edge->getWeight());
                        }
                    }
                }
            }
        }

        Graph(Graph&& ograph) { // move constructor
            nodes = std::move(ograph.nodes);
            ograph.clear(); // check that the nodes are empty
        }

        Graph& operator = (Graph&& ograph) { // move assignment
            if(this != &ograph) {
                nodes = std::move(ograph.nodes);
                ograph.clear(); // check that the nodes are empty
            }
            return *this;
        }

        bool addNode(const N& label) {
            bool is_new = nodes.find(label) == nodes.end();
            if(is_new) {
                std::shared_ptr<N> label_ptr = std::make_shared<N>(label);
                std::shared_ptr<Node> node_ptr{new Node(label_ptr)};

                nodes.emplace(label, node_ptr);
            }
            return is_new;
        }

        bool addEdge(const N& start, const N& end, const E& w) {
            auto node_it = nodes.find(start);
            if(node_it == nodes.end()) {
                throw std::runtime_error("Source node not found");
            }
            auto end_it = nodes.find(end);
            if(end_it == nodes.end()) {
                throw std::runtime_error("Destination node not found");
            }
            return node_it->second->addEdge(node_it->second, end_it->second, w);
        }

        bool replace(const N& old, const N& repl) { // Replace the node label
            auto old_node_it = nodes.find(old); // find the node
            if(old_node_it == nodes.end()) {
                throw std::runtime_error("Node not found");
            }

            bool repl_new = nodes.find(repl) == nodes.end();
            if(repl_new) {
                // TODO PASS TEST5, FIX THIS CODE
                std::shared_ptr<N> repl_ptr{ new N(repl)};
                std::shared_ptr<Node> node = old_node_it->second;

                nodes.erase(old_node_it); // remove the (now invalid) node data

                node->setLabel(repl_ptr);  // update the label
                nodes.emplace(repl, node); // update the map
            }
            return repl_new;
        }

        void mergeReplace(const N& old, const N& repl) { // Move a node into another node
            auto old_it = nodes.find(old);
            if(old_it == nodes.end()) {
                throw std::runtime_error("Old node not found");
            }
            auto repl_it = nodes.find(repl);
            if(repl_it == nodes.end()) {
                throw std::runtime_error("Replacement node not found");
            }
            repl_it->second->mergeEdges(repl_it->second, old_it->second); // Get the edges
            nodes.erase(old_it); // Remove the old node
        }

        void deleteNode(const N& label) noexcept { // Remove a node and its edges
            auto node_it = nodes.find(label);
            if(node_it != nodes.end()) {
                nodes.erase(node_it);
            }
        }

        void deleteEdge(const N& src, const N& dst, const E& w) noexcept { // Remove an Edge
            auto node_it = nodes.find(src);
            if(node_it != nodes.end()) {
                node_it->second->deleteEdge(dst, w);
            }
        }

        void clear() noexcept { // Empty the graph
            // Delete all the nodes (this will delete all the edges)
            while(nodes.begin() != nodes.end()) {
                auto it = nodes.begin();
                deleteNode(it->first); // delete them all
            }
        }

        bool isNode(const N& val) const { // Is the label in the graph
            return nodes.find(val) != nodes.end();
        }

        bool isConnected(const N& src, const N& dst) const { // Is there an edge between src&dst
            auto node_it = nodes.find(src);
            if(node_it == nodes.end()) {
                throw std::runtime_error("Src not found");
            }
            return node_it->second->hasEdge(dst);
        }

        void printNodes() const {
            std::vector<std::pair<N, std::shared_ptr<Node>>> ordered(nodes.begin(), nodes.end());
            struct node_compare {
                bool operator() (const std::pair<N, std::shared_ptr<Node>>& n1, const std::pair<N, std::shared_ptr<Node>>& n2) const {
                    if(n1.second->getOutDegree() == n2.second->getOutDegree()) {
                        return n1.first < n2.first;
                    }
                    return n1.second->getOutDegree() < n2.second->getOutDegree();
                }
            };
            std::sort(ordered.begin(), ordered.end(), node_compare());
            for(auto node : ordered) {
                std::cout << node.first << std::endl;
            }
        }

        void printEdges(const N& val) const {
            auto node_it = nodes.find(val);
            if(node_it == nodes.end()) {
                throw std::runtime_error("Node missing");
            }
            node_it->second->printNode();
        }

        // Iterator functions
        void begin() const { iter = 0; } //nodes.begin(); }

        bool end() const { return iter == nodes.size();} //nodes.end();}

        void next() const { iter++;}

        const N& value() const {
            // the iterator iterates through a map, return the key
            // TODO this is bad, slow and ugly
            int curr = 0;
            for(auto pair : nodes) {
                if(curr == iter) {
                    N* f = new N(pair.first);
                    return *f;
                }
                curr++;
            }
            N* f = new N();
            return *f;
        }

};
